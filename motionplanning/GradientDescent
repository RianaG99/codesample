# -*- coding: utf-8 -*-
"""
Created on Mon Sep 26 15:48:59 2022

@author: riana
"""


#Implements Gradient descent planning algo with a potential function of form
#U = Uatt+Urep

#Implement in simple 2 D space

#Uatt - monotonically increase with distance from q_goal, cap vel
def Uattfun(q_goal,q,ds): #function to calc Uatt and gradient for Uatt
#inputs: q_goal : coordinates of goal in x,y
        # q: current coordinates in x,y
        #ds: threshold distance from goal
        
    xi = 1 #parameter to scale effect of attractive force(NEET TO SET)
    #Uatt(q) = combine conic and quadtratic depending on distance to goal
    if math.dist(q,q_goal) <= ds:
        Uatt = 1/2*xi*math.dist(q,q_goal)**2
    elif math.dist(q,q_goal) > ds:
        Uatt = ds*xi*math.dist(q,q_goal)-1/2*xi*ds**2
    
   #gradUatt(q) = combine conic and quadtratic depending on distance to goal
    if math.dist(q,q_goal) <= ds:
        dUatt = xi*(q-q_goal)
    elif math.dist(q,q_goal) > ds:
        dUatt = (ds*xi*(q-q_goal))/math.dist(q,q_goal) 
       
        #output potential func Uatt and gradient of Uatt
    return Uatt, dUatt

def Urepfun(Qs,q,n,c):
    
    d = np.array([])
    for j in range(len(c[1])):
        alld = math.dist(q,[c[0][j],c[1][j]])
        d = np.append(d,alld)
     #append min dist value for every obstacle and point c
     
    di = np.min(d) 
    ind = np.argmin(d)
    ci = [c[0][ind],c[1][ind]]
    
        
        #find mininum distance to each obstacle
        #find c associated with the closer obs (the smaller dist)
    if di <= Qs: #will Qi change for obstacle?
        Uqi = 1/2*n*(1/di-1/Qs)**2
    elif di > Qs: #change Qis for each?
            Uqi = 0
            
    Urep = Uqi
    ddi = (q-ci)/math.dist(q,ci)

    if di <= Qs: #will Qi change for obstacle?
        dUqi = n*(1/Qs-1/di)*(ddi/di**2)
    elif di > Qs: #change Qis for each?
        dUqi = np.array([0,0])
            
    
    dUrep = dUqi
        
    
    return Urep, dUrep


import numpy as np
import math 
import matplotlib.pyplot as plt

def generatePoints(O):
    pointsx = np.array([])
    pointsy = np.array([])
    for i in range(len(O)-1):
        x = np.linspace(O[i][0],O[i+1][0],20)
        y = np.linspace(O[i][1],O[i+1][1],20)
        
        pointsx = np.append(pointsx,x)
        pointsy = np.append(pointsy,y)
        
    points = np.array([pointsx,pointsy])
    return points

q_start = np.array([0,0])
q_goal = [10,0]

#two square obstacles
#OBSTACLE 1 centered at (4,1) side length 1
v1 = [3.5,0.5]
v2 = [4.5,0.5]
v3 = [4.5,1.5]
v4 = [3.5,1.5]
o1 = np.array([v1,v2,v3,v4,v1])
c1 = generatePoints(o1) # c[0] is all x values and c[1] is all y values


#centered at (7,-1)
w1 = [6.5,-1.5]
w2 = [7.5,-1.5]
w3 = [7.5,-0.5]
w4 = [6.5,-0.5]
o2 = np.array([w1,w2,w3,w4,w1])
c2 = generatePoints(o2)
#OBSTACLE 1 choose radius of .25 centered at qgoal for termination condtion

c = [c1,c2]
e = .25 #radius for termination condition
q = q_start 

Qs = 1 #Distance until robot can ignore obstacle (NEED TO SET)
n = 1 #gain on repulsive function (NEED TO SET?)
ds_goal = 1 # threshold distance from goal(NEED TO SET)
alpha = .1 #should change based on distance to nearest obstacle or goal, smaller as closer to goal?


#The algorithm


#compute gradient of U to get value for dU at starting condition
#O = np.array(o1,o2)
Uatt,dUatt = Uattfun(q_goal, q ,ds_goal)
Urep,dUrep = Urepfun(Qs,q,n,c1)

dU = dUatt+dUrep

path = np.array([])
path = np.append(path,q_start)
U_f = np.array([])
dU_f = np.array([])
i = 0
numOb = 2
while np.linalg.norm(dU) >= e:
    
    Urep = np.array([])
    dUrep = np.array([])
    
    Uatt,dUatt = Uattfun(q_goal,q,ds_goal)
    for neg in range(numOb):
        Urepi,dUrepi = Urepfun(Qs,q,n,c[neg])
        Urep = np.append(Urep,Urepi)
        dUrep = np.append(dUrep,dUrepi)
        
    Urep = np.sum(Urep)
    dUrep = dUrep.reshape(2,2)
    dUrep = dUrep[0] + dUrep[1]
    U = Uatt + Urep #changes based on q, append for all values of q
    dU = dUatt+dUrep
    
    steps = q - alpha*dU #sequence of points to get path
    path = np.append(path,steps)
    i += 1
    q = steps



path = path.reshape(int(len(path)/2),2)


#plot vector field
#plot path generated by planner
#find length of the path

nx, ny = (17,17)
x = np.linspace(-2, 11, nx)
y = np.linspace(-2, 3, ny)
xv, yv = np.meshgrid(x, y)
for i in range(len(xv)):
    for j in range(len(yv)):
        Urep = np.array([])
        dUrep = np.array([])
        if (np.min(o1[:,0]) <= xv[i][j] <= np.max(o1[:,0]) and np.min(o1[:,1]) <= yv[i][j] <= np.max(o1[:,1])) or (np.min(o2[:,0]) <= xv[i][j] <= np.max(o2[:,0]) and np.min(o2[:,1]) <= yv[i][j] <= np.max(o2[:,1])):
            Uatt, dUatt = 0,np.array([0,0])
            Urep, dUrep = 0,np.array([0,0,0,0]) 
        else:
            Uatt,dUatt = Uattfun(q_goal,np.array([xv[i][j],yv[i][j]]),ds_goal)
            for neg in range(numOb):
                Urepi,dUrepi = Urepfun(Qs,np.array([xv[i][j],yv[i][j]]),n,c[neg])
                Urep = np.append(Urep,Urepi)
                dUrep = np.append(dUrep,dUrepi)
        
        Urep = np.sum(Urep)
        dUrep = dUrep.reshape(2,2)
        dUrep = dUrep[0] + dUrep[1]
            
        dU = dUatt+dUrep
        U = Uatt + Urep
        U_f = np.append(U_f,U)
        dU_f = np.append(dU_f,dU)
    
k = 0
dU_f = dU_f.reshape(int(len(dU_f)/2),2)
fig, ax = plt.subplots()
plt.plot(path[:,0],path[:,1])
plt.plot(c1[0],c1[1])
plt.plot(c2[0],c2[1])
plt.scatter(q_goal[0],q_goal[1])
plt.scatter(q_start[0],q_start[1])
for i in range(len(xv)):
    for j in range(len(yv)):
        ax.quiver(xv[i][j], yv[i][j],-dU_f[k,0] , -dU_f[k,1])
        k +=1

    
        
diff = np.array([])
t  = len(path)
for i in range(len(path)-1):
    d = path[i+1] - path[i]
    total = np.linalg.norm(d)
    diff = np.append(diff,total)
    


Total_Traveled = np.sum(diff)
print("Total Length of Path is", Total_Traveled)
        
